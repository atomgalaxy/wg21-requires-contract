---
title: Closure-Based Syntax for Contracts
document: D2461R0
date: 2021-10-06
audience:
  - WG21 SG21 (Contracts)
author:
  - name: Gašper Ažman
    email: <gasper.azman@gmail.com>
  - name: Caleb Sunstrum
    email: <calebs@edg.com>
---

# Introduction

The attribute-derived syntax for contracts is limiting and has as of late come into scrutiny for stepping on the shared space between C and C++. This paper explores an alternative syntax that should hopefully be more powerul while being able to express the same semantics.

**This paper does _not_ intend to change any semantics from [@P2388R2]**. If something looks like a proposed change, that's either a hint at a future extension, or a bug in the paper, so please report it.

The author is actively looking for coauthors, so please don't be shy if you feel like you can contribute.

**Note:** this paper is an exploration. The author does not object to the currently agreed-upon syntax; but it does seem to present certain challenges that this paper tries to address.

# Proposal

## Syntax

We introduce three context-sensitive keywords: `pre`, `post`, and `assert`.
`pre` and `post` are only keywords if at the end of a function declarator.
In the future, we can put other keywords between the keyword and the colon (see example).

`pre` and `post` can appear in function declarations after the place for the optional trailing `requires` clause.

**Example:**

```cpp
auto plus(auto x, auto y) -> decltype(x + y)
    requires(requires(){ {x + y} -> std::integral; }) // show where annotations go
    pre { x > 0 } // proposed here
    pre audit("slow for numeric code") new [&] { // (audit, new) are potential extensions
        /* check for overflow - badly */
        (x > 0 && y > 0 ? as_unsigned(x) + as_unsigned(y) > as_unsigned(x) : true) &&
        // since these are conditional-expressions, use '&&' to combine them
        (x < 0 && y < 0 ? as_unsigned(x) + as_unsigned(y) < as_unsigned(x) : true)
    }
    pre [&y, x, z=x] { // captures that aren't [&] are potential extensions
        // capture y by reference, x by value and copy x into z
        // check that += does the same thing as +
        (z+=y) == (x+y)
    }
    post [&, x, &ret=return] { /* option 1 */
        // we will be changing x, so need to capture x on entry - an extension
        ret == (x + y)
    }
    post [&, x] (auto const& ret) { /* option 2 */
        // we can also opt to specify the return value to be the only argument
        // of a postcondition.
        ret == (x + y)
    }
try { // just to show where try-blocks go 
    assert { x > 0 };
    return x += y;
} catch (...) {
    throw; /* Did you expect something that makes sense? No? Neither did I. */
};
```

### Capture syntax

All captures work like lambda captures, except that they can be omitted (we
don't need the introducer) in which case the _correctness-specifier-body_
block acts as-if the capture is `[&]`.

For `post`, the capture-expression may contain the keyword `return` (for
non-`void` functions). In this context, `return` acts as the alias for the
return variable, and `decltype(return)` is the same as the function return
type.

### Proposed syntax, option 1

Let's take a look at the generic syntax of a _correctness-annotation_ (to use
the term from [@P2388R2]):


| _correctness-specifier_:
|    _correctness-specifier-keyword_ correctness-specifier-introducer~opt~_ _correctness-specifier-body_

| _correctess-specifier-keyword_:
|    `pre` | `post` | `assert`

| _correctness-specifier-introducer_:
|   _lambda-introducer_

| _correctness-specifier-body_:
|   `{` _conditional_expression_ `}`


If the _lambda-introducer_ is omitted, the _correctness-specifier-body_ behaves
as-if the _lambda-introducer_ was `[&]`.

If the _correctness-specifier-keyword_ of the _correctness-specifier_ is
`post`, any _initializer_ of any _init-capture_ in the _lambda-introducer_ may
be the keyword `return`, which behaves as an _id-expression_ denoting
the glvalue or the prvalue result object of the function.

For compatibility with [@P2388R2], we are currently forcing the
`_lambda-introducer_` for `pre` and `assert` to be either `[&]` or omitted.
This gives us the exact semantics [@P2388R2] specifies, but the future
extension is obvious.

For `post`, we must allow the return capture.

### Proposed syntax, option 2

We could allow the `post`-condition grammar to be

| _post-specifier-introducer_:
|   _lambda-introducer_ `(` _parameter-declaration_ `)`

This would separate the parts of the `post` expression evaluated with
pre-conditions (the capture) and the parts evaluated at exit (the body).

This does mean that, due to the ability to omit the `[&]` capture,
`post`-conditions would most commonly look like

```cpp
post (auto const& ret) { ret == x + y }
```

which is longer than

```cpp
post [&, &ret=return] { ret == x + y }
```

by exactly one character.

The author thinks this is not as desirable, as it overspecifies the type of the
return-object, but it does offer a slightly more separated mental model.

## Evaluation order

This section describes the order of evaluation _if contract checking is
enabled_. If it's disabled, there is no evaluation.

### Assertions

Assertions (any `assert`-based _correctness-specifier_) are executed as if they
were immediately-invoked lambda expressions, and are therefore not a problem.

### `pre`- and `post`-conditions

We need to make preceding `pre`-conditions protect both the _lambda-introducer_
and the _correctness-specifier-body_ of any subsequent _correctness-specifier_.

Therefore, `pre`-conditions are executed as is obvious: first the
_correctness-specifier-introducer_ (if any), and then immediately their
_correctness-specifier-body_.

`post-`conditions are evaluated slightly differently; their
_correctness-specifier-introducer_ is evaluated in-sequence along with
`pre`-conditions, **except for any `return`-initializers** (option 1); the
binding of those names is deferred until after function exit.
This is so we can both capture initial values of parameters and
still refer to the result object.

`post`-condition _bodies_ are, obviously, evaluated after the function exits.

If a specifier _B_ follows a specifier _A_ in a function's declaration, then no
part of _B_ shall be executed before _A_ has been checked; This restriction
is of course relaxed for a `pre`-condition appearing after a `post`-condition,
though `post`-conditions still cannot be reordered between each-other.

This means that the following execution orders are all OK:

- _A_, _B_
- _A_, _A_, _B_, _B_
- _A_, _B_, _A_, _B_
- _A_, _B_
- (prove _A_ at compile time), _B_
- (inherit proof of _A_ from caller precondition), _B_

**Consequence 1:** If no `pre`-condition checks fail, the initializers of all
initializers of contract blocks (including `post`-blocks) are evaluated at
function-entry (except `return`-initializers).

**Consequence 2:** It is valid to run the initializers of all `post`-conditions
after the bodies of all `pre`-conditions, since that satisifies the mandate
that initializers of successor specifiers run after the bodies of preceding
`pre`-conditions.

## `post`-condition reference-capture limitations in the MVP

Capturing function parameters by mutable-reference in postconditions may cause difficulties for static analysis, as some expressions containing these will require interprocedural/inter-TU analysis, which may be beyond the capabilities of a compiler. Dedicated static analysis tools should still be able to handle these, however. [@P2388R2] forbids mutating function arguments.

Example (courtesy of Tomasz Kamiński):

```cpp
int pickRandom(int beg, int  end)
    post [&, ret=return] {
        ret >= beg &&
        ret <= end
    };
```

Given that we don't know the function body, and we could have changed `beg` and
`end`, this conveys no information for static analysis (you'd have to mark
`beg` and `end` `const`).

We therefore have a choice of how to start out with this proposal:

- forbid capturing parameters by mutable reference
- forbid capturing parameters by reference altogether
- do nothing and just expect degraded static analysis performance (capture-by-mutable-reference is not a problem for runtime checking)

The stated goal of feature-bijection with [@P2388R2] for this paper says we should forbid reference-capture for parameters in post-conditions and only allow capture-by-value in the MVP.


# New good stuff

- We get improvements in lambda-capture grammar "for free". Once
  lambda-introducers get destructuring support, so do contracts, instead of
  inventing yet another minilanguage.
- We don't have to re-specify anything regarding pack expansions, etc; lambda-introducers get us that, too.
- We can check time/environment-based contracts (see example below).
- Proper support for using the return-value in initializer expressions, and the
  ability to copy the return value so it's not consumed.
- It's consistent with the rest of the language, instead of inventing a yet-another minilanguage.

## Stateful contracts (extension)

A yet-unserved use-case is checking whether a realtime function actually runs in the time promised; this syntax makes it easy:

```cpp
int runs_in_under_10us()
    post [start=gettime()] { gettime() - start <= 10us };
```

Or, perhaps check we didn't leak any memory:

```cpp
int does_not_leak(allocator auto alloc)
    post [usage=alloc.usage(), &alloc] { usage == alloc.usage() };
```

Or, that `sort` actually returns a permutation:

```cpp
void sort(auto first, auto last)
    post audit [&, input=to<vector>(first, last)]
               { is_permutation(input, {first, last}) };
```

The attribute-derived syntax does not suggest an obvious way to do this, since
it doesn't have an obvious closure.

## Destructuring the return value 

We need to reach for an immediately-evaluated lambda expression because we
don't have destructuring support in lambda-introducers, but that'll change,
hopefully, and when it does, we should inherit the fixes.

```cpp
auto returns_triple()
    post [&r=return] { [&] { auto [a, b, c] = r; return c > 0; }() }
{
    struct __private { int __a; int __b; int __c; };
    return __private{1, 2, 3};
}
```

# Challenges with the attribute-derived syntax

This section explores future extensions as envisaged by [@P2388R2] and previous papers.

## Place for annotations like "axiom", "new", etc.

The best idea for where to put such markers is at the end, after a semicolon; from [@P2388R2]/8:

:::cmptable

### This proposal

```cpp
int f(int* p)
    pre {p}
    pre new {*p > 0}
;
```

### [@P2388R2]

```cpp
// after ; at end
int f(int* p)
    [[pre: p]]           // stable annotation
    [[pre: *p > 0; new]] // new annotation
;
```

---

```cpp
int f(int* p)
    pre audit("allows messages") {p}
    pre new("2021-09-27") {*p > 0};
```


```cpp
// after : at end
[[post r: r > 0: new]]
```

---

```cpp
```


```cpp
// in braces at start
[[post{new} r: r > 0]]
```

:::



## Referencing function arguments in postconditions

There are issues with arguments that change value during function evaluation and postconditions. They are described in [@P2388R2]/6.4 and 8.1.
[@P2388R2] side-steps this issue by attempting to prevent referencing modified arguments, requiring that referenced arguments should be `const`-qualified (in definitions).

The ideas using the [@P2388R2] syntax look like this (all from [@P2388R2]/8.1):

:::cmptable

```cpp
// This proposal
int f(int& i, array<int, 8>& arr)
  post [&r=return, i] { r >= i }
  post [&r=return, old_7=arr[7]]
       { r >= old_7 }
```

```cpp
// p2388r2 1)
int f(int& i, array<int, 8>& arr)
  [[post r, old_i = i: r >= old_i]]
  [[post r, old_7 = arr[7]: r >= old_7]];
```

---

```cpp
// p2388r2 3)
int f(int& i, array<int, 8>& arr)
  [[post r: r >= oldof(i)]]
  [[post r: r >= oldof(arr[7])]];
```

```cpp
// p2388r2 2)
int f(int& i, array<int, 8>& arr)
  [[post r: r >= oldof(i)]]
  [[post r: r >= oldof(arr[7])]];
```

:::


:::cmptable

> Another oldof example:

### This proposal

```cpp
template<class ForwardIt, class T>
ForwardIt find(ForwardIt first,
               ForwardIt last,
               const T& value)
  post [&r=return, first]
       { distance(first, r) >= 0u }
  post [&r=return, &last]
       { distance(r, last) >= 0u }
{
  for (; first != last; ++first) {
    if (*first == value) {
      return first;
    }
  }
  return last;
}
```

### P2388R2

```cpp
template<class ForwardIt, class T>
ForwardIt find(ForwardIt first,
               ForwardIt last,
               const T& value)
  [[post r: distance(oldof(first), r) >= 0u]]

  [[post r: distance(r, last) >= 0u]]

{
  for (; first != last; ++first) {
    if (*first == value) {
      return first;
    }
  }
  return last;
}
```

:::



## Introducing the return variable

:::cmptable

### This proposal

```cpp
int f(int* i, array<int, 8>& arr)
    post [&i, r=return] { r >= i };
```

### P2388R2

```cpp
int f(int& i, array<int, 8>& arr)
  [[post r: r >= i]];
```

---

```cpp
```

```cpp
// alternative
int f(int& i, array<int, 8>& arr)
  [[post(r): r >= 0]]
```

:::


## Preconditions and assertions that need copies

:::cmptable

> [@P2388R2] has no answer for preconditions that need to mutate a copy:

### This proposal

```cpp
int f(forward_iterator auto first,
      forward_iterator auto last)
    pre { first != last }
    pre [&, first] { std::advance(first, 1),
                     first != last };
```


### [@P2388R2] Does not work

```cpp
int f(forward_iterator auto first,
      forward_iterator auto last)
    [[pre: first != last]] // ok
    [[pre: std::advance(first, 1), // nope
           first != last]]];
```

:::

## Postconditions that need destructuring [when lambda-captures get it]


:::cmptable

> Functions could concievably have destructure-only APIs:

### This proposal (when lambdas can do this)

```cpp
auto returns_triple()
    post [&[x, y, z]=return]
         { x > y && y > z }
```

### [@P2388R2]-esque

```cpp
auto returns_triple()
    [[post [x, y, z]:
           x > y && y > z]];
```

:::

This syntax kind-of works, but is not proposed, and there is nowhere to specify
the binding type (reference or copy?) We haven't even solved this for lambda
captures, but we will, and we want to inherit the language once we do.

## Summary

- The closure-based syntax makes it obvious when values are captured, and even
  suggests an implementation - just put the closures on the stack before the
  function arguments.
- It doesn't invent another language for capturing values, which means the
  syntax will grow together with lambda captures.
- It makes it **obvious how to do stateful postconditions** that check
  before/after: the closure runs with `pre`, the body runs after return. This
  is far from obvious with the [@P2388R2] syntax.

# Mutation and Static Analyzers

Static analyzers should be able to handle limited mutation in order to analyze
C++, and many contracts that describe function behaviour will require some
mutation of a copy. Allowing copies to be made is therefore immensly useful in
a contract facility.

We have assurances from at least some analyzer vendors they see no issue with
allowing copies and mutation in contract annotations in the future.


# C-compatibility

C and C++ implementations often share a set of system headers, and there will naturally be a desire to add contracts to entities in those headers.

One of the motivating reasons behind the attribute-like syntax in [@P2388R2] is that a C compiler can be reasonably updated to ignore the contracts unless/until C gets Contracts as well. It's worth noting that the proposed syntax in [@P2388R2] is still ill-formed for attributes, and a properly conforming C compiler that has not been updated to handle (ignore) the contracts would still issue diagnostics.

There is some debate as to whether it'd be a _good_ thing if a C compiler were to still accept code that has Contracts in it when the C compiler is unaware of Contracts, and it has been noted that some implementations may simply consume all tokens in an unrecognized attribute until reaching the closing `]]`, regardless of whether the internal structure of the attribute is properly conforming.

The syntax proposed in _this_ paper, however, cannot be ignored by a C compiler that is unaware of Contracts - it is unarguably ill-formed C code.

This syntax lends itself easily to conditional compilation, especially with a feature-test macro:

```cpp
int my_func(int x)
#if __cpp_contracts /* Perhaps just __contracts to allow C to easily opt-in? */
  pre { x > 0; }
#endif /* __cpp_contracts */
{
  /* ... */
}
```

This is not a motivating difference from [@P2388R2] - conditional compilation can just as easily be used to guard Contracts there; the main difference in C-compatibility between these two proposals is that [@P2388R2] has a greater potential of a Contracts-unaware C compiler ignoring any contracts without a meaningful diagnostic or programmer opt-in.

# Proposed Wording

TODO. Writing it will be an exercise, and the author wants to see if there is any enthusiasm for this at all before spending the time.

# Acknowledgements

- _The entire WG21_. This is a huge effort, and since contracts were pulled from C++20, the group has been showing an extraordinary level of determination to get to consensus.
- _Andrzej Krzemieński_, who has been a steadfast integrator of opinion in P2338 - the MVP paper sequence. I've helped a bit, but he's been extraordinary.
- _Tom Honermann_, who saw the interplay with function try-blocks.
- _Phil Nash_, for quite a few insightful comments, and the function-parameter syntax for return values
- _Peter Brett_, for encouraging me to drop the complex sequence of ;-separated conditions and stick to a single condition (subconditions separated by `&&`).
- The _BSI_ for reviewing this paper early.
- _Lisa Lippincott_, for her study of stateful function contracts and all the hours she's spent explaining the point and their shape to me.
- _Tomasz Kamiński_, for *also* pointing out the function parameter syntax for
  return values, and reminding the authors that reference-captures for
  non-const parameters render postconditions less useful for static analysis in the absence of the function body.
